# Контролно по практикум на първа група

### *Забранено е използването на библиотеки различни от iostream*

### *При утечка на памет задачата се оценява с 0т.*

## Задача 01

Нека са дадени три масива `s`, `ind` и `off` с еднаква дължина,
която е фиксирана предварително (максимална дължина 1024), където:

- `s` e масив от символи;
- `ind` е масив от индекси, представени чрез естествени числа;
- `off` е масив от измествания, представени чрез цели числа,

които определят машина с краен брой състояния.

Масивът от индекси ще наричаме лента, а глава на машината
ще наричаме позицията в лентата, на която се намираме в момента.

Известно е, че в началото на нашата програма главата на машината
сочи към определена клетка в лентата.

На база следните правила можем да генерираме низ `res` с крайна дължина,
като за всяка поредна стъпка `l` от работата на машината:

- Нейната глава сочи към определена клетка в `ind`, чиято стойност за улеснение ще бележим с `curr_index`;

- $l$-тият подред елемент на `res` се образува, като вземем символа в `s` на индекс `curr_index`;

- Машината мести своята глава на нова позиция в лентата, като това изместване се задава
  на база $l$-тия подред елемент в масива от измествания `off`, като за улеснение
  ще бележим това изместване с `curr_offset`:

  - ако `curr_offset >= 0`, то главата се измества с $curr\_offset$ позиции надясно;
  - ако `curr_offset <  0`, то главата се измества с $|curr\_offset|$ позиции наляво;
  - ако на някакъв етап излезем извън границите на лентата,
    то се прехвърляме в другата част на лентата. Например, за лента с четири клетки и изместване от `-2`:

<pre style="font-family: monospace; line-height: 1.2;">
┌───┐   ┌───┐   ┌───┐   ┌───┐
│ 1 │──►│ 2 │──►│ 3 │──►│ 4 │
└───┘   └───┘   └───┘   └───┘
          ▲
          │
        глава
</pre>

<pre style="font-family: monospace; line-height: 1.2;">
┌───┐   ┌───┐   ┌───┐   ┌───┐
│ 1 │──►│ 2 │──►│ 3 │──►│ 4 │
└───┘   └───┘   └───┘   └───┘
                          ▲
                          │
                        глава
</pre>

Възможно е дължината на търсения низ да бъде по-голяма от броя на елементите
в масива с измествания. Ако в някакъв момент стигнем края на масива с измествания,
се връщаме обратно в неговото начало.

**Да се напише програма, която по подадени глава на лентата `start` и естествено число `k`
намира низа с дължина `k`, образуващ се по горните правила.**

*Забележка*: За улеснение приемаме, че позиците започват от 0
и че индексите в `ind` винаги ще бъдат валидни за `s`. Може да приемете,
че и трите масива са с някакви фиксирани елементи, т.е. няма нужда да ги
въвеждате от стандартния вход.

*Пример*:

Нека са дадени масивите:

```c++
s:   ['a', 'f', 'l', 'i', 'm']
ind: [0, 3, 1, 4, 0]
off: [1, -2, 5, -3, 0]
```

Тогава:

```c++
Вход:  start = 2; k = 3
Изход: "fmi"
```

*Обяснение на примера*:

- $l = 1$. Първоначалната ни позиция `start` има стойност 2, което
  съответства на индекс `1` в `ind`. Тогава първият елемент на резултатния низ
  е елементът в `s` на индекс `1`, а именно - `'f'`.
  Първият елемент в масива с измествания е `1`, така че изместваме главата на машината
  с една позиция надясно по лентата, т.е. от позиция 2 се местим на позиция 3.

- $l = 2$. Намираме се на позиция 3, което ни дава индекс `4` в масива `ind`.
  Тогава вторият елемент на резултатния низ е елементът в `s` на индекс `4`,
  а именно - `'m'`.
  Вторият елемент в масива с измествания е `-2`, така че изместваме главата на машината
  с две позиции наляво по лентата, т.е. от позиция 3 се местим на позиция 1.

- $l = 3$. Намираме се на позиция 1, което ни дава индекс `3` в масива `ind`.
  Тогава третият елемент на резултатния низ е елементът в `s` на индекс `3`,
  а именно - `'i'`.
  Третият елемент в масива с измествания е `5`, така че изместваме главата на машината
  с пет позиции надясно по лентата, т.е. изместваме се до позиция 5 в лентата,
  за което са били нужни три измествания надясно, така че се връщаме в началото
  на лентата (позиция 0), което само по себе си отнема едно изместване, и остава да се изместим
  още веднъж, т.е. от позиция 0 да се измествим до позиция 1.

Така резултатният низ е станал `"fmi"`.

## Задача 02

От стандарния вход се чете число `k` и след това `k` на брой символи,
където всеки символ има една от две възможни стойности: `'h'` или `'t'`,
като всеки от символите бележи лице на монета, съответно ези или тура.

Да се напише функция, която приема такъв низ и връща минималния
брой необходими размествания на монетите, така че всички монети
с лице ези да се намират преди всички монети с лице тура.

*Забележка*: Не е задължително разместванията в низа да бъдат
на съседни елементи.

*Пример*:

```c++
Вход: "httttht"
Изход: 1
```

## Задача 03

От стандарния вход се четат две числа `m` и `n`, които бележат
съответно брой редове и брой колони в матрица с реални числа, като елементите
на матрицата също се въвеждат от стандарния вход.

Да се напише функция, която приема такава матрица и връща
броя на локалните екстремуми в матрицата.

Локален екстремум в матрица ще наричаме такъв елемент в матрицата,
за който всичките му съседни елементи или са по-големи от него,
или са по-малки от него. Съседни елементи на някакъв елемент
с координати $(x,y)$ са тези елементи с координати $(x_i, y_i)$ с $(x,y) \neq (x_i, y_i)$,
за които е вярно, че: $|x - x_i| \leq 1$ \& $|y - y_i| \leq 1$.

*Пример*:

```c++
Вход: m = 3; n = 3

[ [1, 5, 0]
, [2, 3, 4]
, [9, 8, 5] ]

Изход: 4  // локалните екстремуми са 1, 5, 0 и 9
```
