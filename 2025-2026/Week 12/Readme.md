# Динамични матрици. Рекурсия - 07.01.2026

## Задача 01

Да се напишат функции, която по подадена квадратна матрица:

- извеждат на конзолата елементите на вторичния диагонал;

- извеждат на конзолата елементите под вторичния диагонал, обхождайки тази част от масива по диагонали.

Размерът на матрицата и елементите ѝ се въвеждат от конзолата.

Пример:

```c++
Вход: 3           Изход: 3 5 7
      1 2 3              
      4 5 6              6 8
      7 8 9              9
```

## Задача 02

Даден е масив с максимална големина 10 елемента. Напишете програма, в която потребителят въвежда числа или докато не въведе 10 положителни числа, или не въведе числото 0. За всяко число `n` в масива се заделя количество памет за нов масив `arr`, който като първи елемент има големината на `arr`, а останалите елементи в `arr` са `n` на брой. След въвеждането на тези <= 10 числа да се позволи на потребителя да въведе съответния брой елементи за всеки от подмасивите на оригиналния масив. След това тези масиви да се изведат на конзолата.

Пример:

```c++
Вход: 3 4 -12 1 0         Изход: 1 2 3
      1 2 3                      0 0 0 0
      0 0 0 0                    42
      42
```

## Задача 03

Да се напише функция `void split(char const* str, char** dest, char delim)`, която разделя `str` на множество от низове, които се записват в `dest`, спрямо разделителя `delim`.

Пример:
```c++
split("pointers$are$cool",dest,'$');
//~> dest == ["pointers","are","cool"]
```

*Забележка*: Друг вариант е да връщате новозаделеният масив от низова (`dest`) от самата функция. Опитайте се да реализирате функцията и по двата начина.

## Задача 04

Дадена е матрица с размерност, която се чете от стандартния вход, и елементи и низ с максимална дължина 128 символа, състоящ се **само** от символите `u(p)` , `d(own)`, `l(eft)` и `r(ight)`, който се въвежда от потребителя. След това се въвеждат начални и крайни координати под формата на наредени двойки. 

а) Да се напише функция, която проверява дали крайната точка може да бъде достигната от началната чрез последователното изпълнение на **всички** движения, кодирани в низа.

б) Да се напише друга функция, която, ако крайната точка не може да бъде достигната от началната, проверява дали съответната крайна точка може да бъде достигната чрез промяната на **едно единствено** движение, кодирано в низа.

## Задача 05

Да се напише програма, която приема текст само с латински букви, цифри и интервали. Текстът е с дължина до 2048 символа. Програмата да позволява промяна на дума по индекс и цензуриране и разцензуриране на вече цензурирана на дума по индекс. На всяка опрация да се отпечатва текста:

```c++
Hello my 320 friends how are you

> censor
> 2

Hello my * friends how are you

> censore 
> 4

Hello my * friends * are you

> uncensore 
> 2

Hello my 320 friends * are you

> change
> friends
> enemies

Hello my 320 enemies * are you
```

## Задача 06

Напишете *рекурсивна* функция, която приема цяло неотрицателно число `n` и връща сумата на `n` и всички по-малки от него естествени числа.

## Задача 07

Напишете *рекурсивна* функция, която приема неотрицателно число `n` и връща троен факториел (`n!!!`) от него.

*Забележка*:
```
0!!! = 1
n!!! = n*(n-3)*(n-6)*...*(n-3*i), 3 >= n-3*i > 0
```

## Задача 08

Напишете *рекурсивна* функция, която приема цяло число `n` и връща сумата на цифрите му.

Пример:

```c++
digitSum(-123)  // ~> 6
```

## Задача 09

Напишете *рекурсивна* функция, която приема цяло число `n` и връща дали е степен на двойката.

## Задача 10

Дадени са `n` на брой стълби. Да се напише функция, която връща броя различни начини, по които могат да се изкачат тези стълби, като на всяка стъпка могат да се изкачват 1 или 2 стълби.

## Задача 11

Да се напише *рекурсивна* функция, която приема символен низ и връща дали той е палиндром.

## Задача 12

Да се напише *рекурсивна* функция, която приема число `n` и извежда на конзолата елементите на редицата, дефинирана по следния начин:

$$
\begin{equation}
 a_{i+1} =
   \begin{cases}
       a_i, & a_i = 1 \\
       a_i/2, & a_i \mod 2 \equiv 0 \\
       3a_i + 1, & a_i \mod 2 \equiv 1 \\
    \end{cases}
\end{equation}
$$

за $i < 500$.

## Задача 13

Да се напише *рекурсивна* функция, която приема масив от цели числа и връща разликата им, обхождайки масива от дясно наляво.

Пример:

```
[1,2,3,4,5]  -> (((5-4)-3)-2)-1 = -5
```

## Задача 14

Да се напише *рекурсивна* функция, която приема масив от цели числа и връща частното на елементите на нечетни индекси в масива, обхождайки го от ляво надясно. Приемаме, че масивът ще има поне 2 елемента.

Пример:

```
[0,8,0,4,0,4]  -> (8/4)/4 = 0.5
```

## Задача 15

Да се напише *рекурсивна* функция, която приема квадратна матрица и записва елементите от главния ѝ диагонал в масив.

## Задача 16

Да се напише *рекурсивна* функция, която приема матрица с размер MxN и връща сумата на минималните елементи от всеки матричен ред. Да **не** се използват никакви итеративни подходи. 

## Задача 17

Да се напише *рекурсивна* функция, която да пресмята детерминантата на матрица от n-ти ред.
